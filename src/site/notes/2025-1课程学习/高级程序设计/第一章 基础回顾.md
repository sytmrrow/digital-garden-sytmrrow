---
{"dg-publish":true,"tags":["信管课程"],"permalink":"/2025-1课程学习/高级程序设计/第一章 基础回顾/","dgPassFrontmatter":true,"created":"2024-12-31T12:09:47.553+08:00","updated":"2025-01-08T06:24:21.370+08:00"}
---

## 一、String不可变类
	string 是一个不可变类，其底层是一个用final修饰的char[]数组，在java9中更新为紧凑类型的byte[]数组，如果对一个String类型的的对象进行字面量的显式赋值，它会在字符串常量池中开辟一个空间，如果修改这个对象的值，例如将String a = "aaa",变为a="bbb"，那原本的“aaa"字符串并不会消失，而是在常量池中新创建了一个”bbb"对象，并将其地址返回给a，这就是String的不可变的原因，指的是内存空间中（堆/常量池）一旦创建了一个字符串的对象，那么这个对象就不会消失或者原地被改变。
	同样的，如果是String b ="aaa"，那么这个b会直接指向常量池中的"aaa"。
	第二种构建的方式是通过new一个对象进行，如果是通过这种方式String c = new String("aaa")，这种方式，由于常量池中已经有“aaa"了，因此常量池中不会更新，但是在堆中会出现一个新的String字符串对象，内容与”aaa“相同，具体这个对象与常量池中的”aaa“究竟是直接复制还是指向取决于jvm的实现方式，其次如果new的这个对象的字面量是没有在常量池中出现的，例如String d = new String("ddd")，由于代码中出现了字面量”ddd“那么这个常量池中就会更新一个”ddd“，同时会在堆中创建一个String对象，这个d指向的是堆中的对象。

tips:实际上如果想要修改String的类型，可以通过反射机制获得它的底层的数组，通过修改数组的方式进行修改。

## 二、StringBuffer与StringBuilder可变类
	对于StringBuffer和StringBuilder是可以原地在地址的基础上修改值的，两者之间的差别主要是关于线程是否安全以及因此引发的性能差异。
	StringBuffer是线程同步安全的，在多个线程同时对同一个StringBuffer对象进行操作时，由于StringBuffer的方法中自带了synchronized关键字或者在方法的内部进行了同步，因此它是线程安全的。
	而StringBuilder却不是线程安全的，如果多个线程同时访问并修改它，可能导致数据不一致或者线程竞争情况，不过因为其不像StringBuffer一样有同步机制，因此其在单线程中效率更高。
	StringBuffer与StringBuilder的适用场景不同，StringBuilder适用于少线程竞争的环境，因为在这种环境下使用StringBuffer会有额外的不必要的同步开销，因此在单线程情况下使用StringBuilder更合适。在多线程情况下且需要保证线程安全的情况使用StringBuffer可能是更加合适的，不过在真实环境的开发中，工程师可能会选择在多线程的机制下使用局部的StringBuilder，这样可以在保证同步的情况下享受StringBuilder的高性能。

## 三、回溯与递归算法
### 模式匹配
<font color="#c00000">正则表达式</font>描述了一种字符串匹配的模式，可以用来检查一个字符串中是否存在某种子串或者某种模式，将其进行替换或者将其取出

## 四、关于byte
byte是字节，由8位的二进制组成，范围从-127到128
关于二进制的补码规则，如果二进制是0开头，是正数，其值就是二进制的数本身，如果是1开头则取反+1，获得最终的结果后，加上一个负号就是其表示的值